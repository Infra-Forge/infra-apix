package main

import (
	"bytes"
	"context"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	apix "github.com/Infra-Forge/infra-apix"
	"github.com/Infra-Forge/infra-apix/openapi"
	"github.com/getkin/kin-openapi/openapi3"
)

const doNotEditHeader = "# DO NOT EDIT -- generated by apix generate -- update Go handlers instead"

func main() {
	log.SetFlags(0)
	if err := runCLI(context.Background(), os.Args[1:]); err != nil {
		var cmdErr commandError
		if errors.As(err, &cmdErr) && cmdErr.command != "" {
			log.Fatalf("apix %s: %v", cmdErr.command, cmdErr.err)
		}
		log.Fatalf("apix: %v", err)
	}
}

type commandError struct {
	command string
	err     error
}

func (c commandError) Error() string {
	if c.command == "" {
		return c.err.Error()
	}
	return fmt.Sprintf("%s: %v", c.command, c.err)
}

func (c commandError) Unwrap() error {
	return c.err
}

func runCLI(ctx context.Context, args []string) error {
	fs := flag.NewFlagSet("apix", flag.ContinueOnError)
	fs.SetOutput(io.Discard)

	flagProject := fs.String("project", ".", "Path to Go project (root for handler registration)")
	flagOut := fs.String("out", "docs/openapi.yaml", "Output path for OpenAPI spec")
	flagFormat := fs.String("format", "yaml", "Output format: yaml or json")
	flagTitle := fs.String("title", "API", "API title")
	flagVersion := fs.String("version", "1.0.0", "API version")
	flagServers := fs.String("servers", "", "Comma-separated server URLs")
	flagStdout := fs.Bool("stdout", false, "Write spec to stdout instead of file")
	flagValidate := fs.Bool("validate", true, "Validate generated spec")
	flagExisting := fs.String("existing", "", "Existing spec to compare against (defaults to --out)")

	var command string
	rest := args
	if len(rest) > 0 && !strings.HasPrefix(rest[0], "-") {
		command = rest[0]
		rest = rest[1:]
	}

	if err := fs.Parse(rest); err != nil {
		if errors.Is(err, flag.ErrHelp) {
			return nil
		}
		return err
	}

	if command == "" {
		if fs.NArg() > 0 {
			command = fs.Arg(0)
		}
	}

	cfg := generateConfig{
		projectPath: *flagProject,
		outputPath:  *flagOut,
		format:      *flagFormat,
		title:       *flagTitle,
		version:     *flagVersion,
		servers:     parseServers(*flagServers),
		stdout:      *flagStdout,
		validate:    *flagValidate,
	}

	switch command {
	case "", "generate":
		if err := runGenerate(ctx, cfg); err != nil {
			return commandError{command: "generate", err: err}
		}
		return nil
	case "spec-guard":
		if err := runSpecGuard(ctx, cfg, *flagExisting); err != nil {
			return commandError{command: "spec-guard", err: err}
		}
		return nil
	case "help", "-h", "--help":
		fs.Usage()
		return nil
	default:
		return fmt.Errorf("unknown command %q", command)
	}
}

type generateConfig struct {
	projectPath string
	outputPath  string
	format      string
	title       string
	version     string
	servers     []string
	stdout      bool
	validate    bool
}

func runGenerate(ctx context.Context, cfg generateConfig) error {
	payload, err := buildSpecPayload(ctx, cfg)
	if err != nil {
		return err
	}

	if cfg.stdout {
		fmt.Fprintln(os.Stdout, doNotEditHeader)
		if _, err := os.Stdout.Write(payload[len(doNotEditHeader)+2:]); err != nil {
			return fmt.Errorf("write spec to stdout: %w", err)
		}
		return nil
	}

	outPath := filepath.Clean(cfg.outputPath)
	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		return fmt.Errorf("create output dir: %w", err)
	}

	if err := os.WriteFile(outPath, payload, 0o644); err != nil {
		return fmt.Errorf("write spec: %w", err)
	}

	return nil
}

func buildSpecPayload(ctx context.Context, cfg generateConfig) ([]byte, error) {
	oldWD, err := os.Getwd()
	if err != nil {
		return nil, fmt.Errorf("determine working directory: %w", err)
	}
	if err := os.Chdir(cfg.projectPath); err != nil {
		return nil, fmt.Errorf("failed to enter project: %w", err)
	}
	defer func() {
		_ = os.Chdir(oldWD)
	}()

	routes := apix.Snapshot()
	if len(routes) == 0 {
		return nil, errors.New("no routes registered; ensure your handlers register with apix")
	}

	b := openapi.NewBuilder()
	b.Info.Title = cfg.title
	b.Info.Version = cfg.version
	for _, srv := range cfg.servers {
		if strings.TrimSpace(srv) == "" {
			continue
		}
		b.Servers = append(b.Servers, &openapi3.Server{URL: srv})
	}

	doc, err := b.Build(routes)
	if err != nil {
		return nil, fmt.Errorf("build openapi: %w", err)
	}

	if cfg.validate {
		if err := doc.Validate(ctx); err != nil {
			return nil, fmt.Errorf("validate openapi: %w", err)
		}
	}

	data, _, err := encodeDoc(doc, cfg.format)
	if err != nil {
		return nil, err
	}

	payload := append([]byte(doNotEditHeader+"\n\n"), data...)
	return payload, nil
}

func runSpecGuard(ctx context.Context, cfg generateConfig, existingPathFlag string) error {
	tmp, err := os.CreateTemp("", "apix-spec-*.tmp")
	if err != nil {
		return fmt.Errorf("create temp file: %w", err)
	}
	tmp.Close()
	defer os.Remove(tmp.Name())

	tempCfg := cfg
	tempCfg.outputPath = tmp.Name()
	tempCfg.stdout = false

	expected, err := buildSpecPayload(ctx, tempCfg)
	if err != nil {
		return fmt.Errorf("generate spec: %w", err)
	}

	existingPath := existingPathFlag
	if strings.TrimSpace(existingPath) == "" {
		existingPath = cfg.outputPath
	}
	if !filepath.IsAbs(existingPath) {
		existingPath = filepath.Join(cfg.projectPath, existingPath)
	}
	existingPath = filepath.Clean(existingPath)

	current, err := os.ReadFile(existingPath)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return fmt.Errorf("spec file missing at %s; run 'apix generate' to create it", existingPath)
		}
		return fmt.Errorf("read existing spec: %w", err)
	}

	if !bytes.Equal(expected, current) {
		return fmt.Errorf("spec drift detected at %s; run 'apix generate' to update the committed spec", existingPath)
	}

	return nil
}

func encodeDoc(doc *openapi3.T, format string) ([]byte, string, error) {
	return openapi.EncodeDocument(doc, format)
}

func parseServers(raw string) []string {
	if raw == "" {
		return nil
	}
	parts := strings.Split(raw, ",")
	result := make([]string, 0, len(parts))
	for _, p := range parts {
		trimmed := strings.TrimSpace(p)
		if trimmed != "" {
			result = append(result, trimmed)
		}
	}
	sort.Strings(result)
	return result
}
